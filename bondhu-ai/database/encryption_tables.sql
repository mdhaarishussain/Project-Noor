-- Database schema for encryption keys
-- Creates tables for storing user public keys and session keys

-- Create user_keys table for storing user public keys
CREATE TABLE IF NOT EXISTS user_keys (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    public_key TEXT NOT NULL,
    key_type TEXT NOT NULL DEFAULT 'RSA-2048',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add unique constraint to prevent duplicate keys per user
DO $$ 
BEGIN 
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'unique_user_key'
    ) THEN
        ALTER TABLE user_keys
        ADD CONSTRAINT unique_user_key UNIQUE (user_id);
    END IF;
END $$;

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_user_keys_user_id ON user_keys(user_id);
CREATE INDEX IF NOT EXISTS idx_user_keys_created_at ON user_keys(created_at);

-- Add table comments for documentation
COMMENT ON TABLE user_keys IS 'Stores public keys for each user for end-to-end encryption';
COMMENT ON COLUMN user_keys.user_id IS 'The user this key belongs to';
COMMENT ON COLUMN user_keys.public_key IS 'User''s public key in PEM format';
COMMENT ON COLUMN user_keys.key_type IS 'Type of key (e.g., RSA-2048, ECC)';

-- Create session_keys table for storing encrypted session keys
CREATE TABLE IF NOT EXISTS session_keys (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id UUID NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    encrypted_key TEXT NOT NULL,
    recipient_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_session_keys_session_id ON session_keys(session_id);
CREATE INDEX IF NOT EXISTS idx_session_keys_user_id ON session_keys(user_id);
CREATE INDEX IF NOT EXISTS idx_session_keys_recipient_user_id ON session_keys(recipient_user_id);
CREATE INDEX IF NOT EXISTS idx_session_keys_created_at ON session_keys(created_at);

-- Add table comments for documentation
COMMENT ON TABLE session_keys IS 'Stores encrypted session keys for end-to-end encryption';
COMMENT ON COLUMN session_keys.session_id IS 'The session this key is for';
COMMENT ON COLUMN session_keys.user_id IS 'The user who owns this key entry';
COMMENT ON COLUMN session_keys.encrypted_key IS 'Session key encrypted with recipient''s public key (hex encoded)';
COMMENT ON COLUMN session_keys.recipient_user_id IS 'The user who can decrypt this key';

-- Enable Row Level Security
ALTER TABLE user_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_keys ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own keys" ON user_keys;
DROP POLICY IF EXISTS "Users can insert their own keys" ON user_keys;
DROP POLICY IF EXISTS "Users can update their own keys" ON user_keys;
DROP POLICY IF EXISTS "Users can delete their own keys" ON user_keys;

DROP POLICY IF EXISTS "Users can view their session keys" ON session_keys;
DROP POLICY IF EXISTS "Users can insert session keys" ON session_keys;
DROP POLICY IF EXISTS "Users can update session keys" ON session_keys;
DROP POLICY IF EXISTS "Users can delete session keys" ON session_keys;

-- Create RLS policies for user_keys
CREATE POLICY "Users can view their own keys" ON user_keys FOR
    SELECT USING (auth.uid() = user_id);
    
CREATE POLICY "Users can insert their own keys" ON user_keys FOR
    INSERT WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "Users can update their own keys" ON user_keys FOR
    UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "Users can delete their own keys" ON user_keys FOR
    DELETE USING (auth.uid() = user_id);

-- Create RLS policies for session_keys
CREATE POLICY "Users can view their session keys" ON session_keys FOR
    SELECT USING (auth.uid() = user_id OR auth.uid() = recipient_user_id);
    
CREATE POLICY "Users can insert session keys" ON session_keys FOR
    INSERT WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "Users can update session keys" ON session_keys FOR
    UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "Users can delete session keys" ON session_keys FOR
    DELETE USING (auth.uid() = user_id);

-- Grant appropriate permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON user_keys TO authenticated;
GRANT USAGE ON SEQUENCE user_keys_id_seq TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON session_keys TO authenticated;
GRANT USAGE ON SEQUENCE session_keys_id_seq TO authenticated;

-- Add trigger function to automatically update the updated_at timestamp for user_keys
CREATE OR REPLACE FUNCTION update_updated_at_column() RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic updated_at updates
DROP TRIGGER IF EXISTS update_user_keys_updated_at ON user_keys;
CREATE TRIGGER update_user_keys_updated_at 
    BEFORE UPDATE ON user_keys 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
